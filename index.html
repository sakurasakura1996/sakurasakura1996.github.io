<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CS, AI, Daily Life">
<meta property="og:type" content="website">
<meta property="og:title" content="SAKURA">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SAKURA">
<meta property="og:description" content="CS, AI, Daily Life">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="SAKURA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SAKURA</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SAKURA</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">sakura's blog for everything!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/22%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SAKURA">
      <meta itemprop="description" content="CS, AI, Daily Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SAKURA">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/09/22%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" class="post-title-link" itemprop="url">LeetCode problem22 括号生成</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-09 16:03:04 / 修改时间：16:04:18" itemprop="dateCreated datePublished" datetime="2020-04-09T16:03:04+08:00">2020-04-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例：</p>
<p>输入：n = 3</p>
<p>输出：[</p>
<pre><code>   &quot;((()))&quot;,

   &quot;(()())&quot;,

   &quot;(())()&quot;,

   &quot;()(())&quot;,

   &quot;()()()&quot;

 ]
</code></pre><p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><strong>方法一：暴力法</strong></p>
<p>这个方法着实有点僵硬，因为如果暴力列举的话，有2^(2n)个序列，然后检查每一个是否有效，检查每一个的时间复杂度是O(n)，那么总的时间复杂度是O(n*2^(2n))。</p>
<p><strong>算法</strong></p>
<p>为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。</p>
<p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。如果在遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        def generate(A):</span><br><span class="line">            if len(A) &#x3D;&#x3D; 2*n:</span><br><span class="line">                if valid(A):</span><br><span class="line">                    ans.append(&quot;&quot;.join(A))</span><br><span class="line">            else:</span><br><span class="line">                A.append(&#39;(&#39;)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(&#39;)&#39;)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        def valid(A):</span><br><span class="line">            bal &#x3D; 0</span><br><span class="line">            for c in A:</span><br><span class="line">                if c &#x3D;&#x3D; &#39;(&#39;: bal +&#x3D; 1</span><br><span class="line">                else: bal -&#x3D; 1</span><br><span class="line">                if bal &lt; 0: return False</span><br><span class="line">            return bal &#x3D;&#x3D; 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        generate([])</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;generate-parentheses&#x2F;solution&#x2F;gua-hao-sheng-cheng-by-leetcode-solution&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><strong>方法二：回溯法</strong></p>
<p><strong>思路和算法</strong></p>
<p>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，</p>
<p>如果左括号数量不大于 nn，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        def backtrack(S, left, right):</span><br><span class="line">            if len(S) &#x3D;&#x3D; 2 * n:</span><br><span class="line">                ans.append(&#39;&#39;.join(S))</span><br><span class="line">                return</span><br><span class="line">            if left &lt; n:</span><br><span class="line">                S.append(&#39;(&#39;)</span><br><span class="line">                backtrack(S, left+1, right)</span><br><span class="line">                S.pop()</span><br><span class="line">            if right &lt; left:</span><br><span class="line">                S.append(&#39;)&#39;)</span><br><span class="line">                backtrack(S, left, right+1)</span><br><span class="line">                S.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtrack([], 0, 0)</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;generate-parentheses&#x2F;solution&#x2F;gua-hao-sheng-cheng-by-leetcode-solution&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><strong>方法三：按括号序列的长度递归</strong></p>
<p><strong>思路与算法</strong></p>
<p>任何一个括号序列都一定是由 ( 开头，并且第一个 ( 一定有一个唯一与之对应的 )。这样一来，每一个括号序列可以用 (a)b 来表示，其中 a 与 b 分别是一个合法的括号序列（可以为空）。</p>
<p>那么，要生成所有长度为 2 * n 的括号序列，我们定义一个函数 generate(n) 来返回所有可能的括号序列。那么在函数 generate(n) 的过程中：</p>
<p>我们需要枚举与第一个 ( 对应的 ) 的位置 2 * i + 1；</p>
<p>递归调用 generate(i) 即可计算 a 的所有可能性；</p>
<p>递归调用 generate(n - i - 1) 即可计算 b 的所有可能性；</p>
<p>遍历 a 与 b 的所有可能性并拼接，即可得到所有长度为 2 * n 的括号序列。</p>
<p>为了节省计算时间，我们在每次 generate(i) 函数返回之前，把返回值存储起来，下次再调用 generate(i) 时可以直接返回，不需要再递归计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return [&#39;&#39;]</span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        for c in range(n):</span><br><span class="line">            for left in self.generateParenthesis(c):</span><br><span class="line">                for right in self.generateParenthesis(n-1-c):</span><br><span class="line">                    ans.append(&#39;(&#123;&#125;)&#123;&#125;&#39;.format(left, right))</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;generate-parentheses&#x2F;solution&#x2F;gua-hao-sheng-cheng-by-leetcode-solution&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>个人觉得第三种方法就比较好，代码简单，而且理解起来也不算太难。</p>
<h2 id="精选题解："><a href="#精选题解：" class="headerlink" title="精选题解："></a>精选题解：</h2><p><strong>方法三：动态规划</strong></p>
<p>参考了本题的 「官方题解」 中的 “闭合数方法” 和 「精选题解」，同样的方法也可以用来完成 「力扣」第 95 题：“不同的二叉搜索树 II”。</p>
<p>第 1 步：定义状态 dp[i]：使用 i 对括号能够生成的组合。</p>
<p>注意：每一个状态都是列表的形式。</p>
<p>第 2 步：状态转移方程：</p>
<p>i 对括号的一个组合，在 i - 1 对括号的基础上得到，这是思考 “状态转移方程” 的基础；</p>
<p>i 对括号的一个组合，一定以左括号 “(“ 开始，不一定以 “)” 结尾。为此，我们可以枚举新的右括号 “)” 可能所处的位置，得到所有的组合；</p>
<p>枚举的方式就是枚举左括号 “(“ 和右括号 “)” 中间可能的合法的括号对数，而剩下的合法的括号对数在与第一个左括号 “(“ 配对的右括号 “)” 的后面，这就用到了以前的状态。</p>
<p>状态转移方程是：</p>
<p>dp[i] = “(“ + dp[可能的括号对数] + “)” + dp[剩下的括号对数]</p>
<p>“可能的括号对数” 与 “剩下的括号对数” 之和得为 i - 1（感谢 @xuyik 朋友纠正了我的错误），故 “可能的括号对数” j 可以从 0 开始，最多不能超过 i， 即 i - 1；</p>
<p>“剩下的括号对数” + j = i - 1，故 “剩下的括号对数” = i - j - 1。</p>
<p>整理得：</p>
<p>dp[i] = “(“ + dp[j] + “)” + dp[i- j - 1] , j = 0, 1, …, i - 1</p>
<p>第 3 步： 思考初始状态和输出：</p>
<p>初始状态：因为我们需要 0 对括号这种状态，因此状态数组 dp 从 0 开始，0 个括号当然就是 [“”]。</p>
<p>输出：dp[n] 。</p>
<p>这个方法暂且就叫它动态规划，这么用也是很神奇的，它有下面两个特点：</p>
<p>1、自底向上：从小规模问题开始，逐渐得到大规模问题的解集；</p>
<p>2、无后效性：后面的结果的得到，不会影响到前面的结果。</p>
<p>作者：liweiwei1419</p>
<p>链接：<a href="https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/solution/hui-su-suan-fa-by-liweiwei1419/</a></p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        if n &#x3D;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line">        dp &#x3D; [None for _ in range(n + 1)]</span><br><span class="line">        dp[0] &#x3D; [&quot;&quot;]</span><br><span class="line">        for i in range(1, n + 1):</span><br><span class="line">            cur &#x3D; []</span><br><span class="line">            for j in range(i):</span><br><span class="line">                left &#x3D; dp[j]</span><br><span class="line">                right &#x3D; dp[i - j - 1]</span><br><span class="line">                for s1 in left:</span><br><span class="line">                    for s2 in right:</span><br><span class="line">                        cur.append(&quot;(&quot; + s1 + &quot;)&quot; + s2)</span><br><span class="line">            dp[i] &#x3D; cur</span><br></pre></td></tr></table></figure>
<pre><code>    return dp[n]
</code></pre><p>仔细看来，这个动态规划的思想和官方题解的方法三是十分相似的逻辑。<br><strong>DFS</strong></p>
<p>我们可以看成树形结构的深度优先搜索。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from typing import List</span><br><span class="line">class Solution:</span><br><span class="line">	def generateParenthesis(self, n:int)-&gt; List[str]:</span><br><span class="line">		res &#x3D; []</span><br><span class="line">		cur_str &#x3D; &#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		def dfs(cur_str, left, right):</span><br><span class="line">			&quot;&quot;&quot;</span><br><span class="line">            :param cur_str: 从根结点到叶子结点的路径字符串</span><br><span class="line">            :param left: 左括号还可以使用的个数</span><br><span class="line">            :param right: 右括号还可以使用的个数</span><br><span class="line">            :return:</span><br><span class="line">            &quot;&quot;&quot;</span><br><span class="line">            if left &#x3D;&#x3D; 0 and right &#x3D;&#x3D; 0:</span><br><span class="line">            	res.append(cur_str)</span><br><span class="line">            	return</span><br><span class="line">            if right&lt;left:</span><br><span class="line">            	return</span><br><span class="line">            if left&gt;0:</span><br><span class="line">            	dfs(cur_str+&#39;(&#39;,left-1,right) </span><br><span class="line">            if right&gt;0:</span><br><span class="line">            	dfs(cur_str+&#39;)&#39;,left,right-1)</span><br><span class="line">            dfs(cur_str, n,n)</span><br><span class="line">            return res</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%9813.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SAKURA">
      <meta itemprop="description" content="CS, AI, Daily Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SAKURA">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/%E9%9D%A2%E8%AF%95%E9%A2%9813.%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" class="post-title-link" itemprop="url">LeetCode 面试题13 机器人的运动范围</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-08 13:17:38 / 修改时间：13:19:26" itemprop="dateCreated datePublished" datetime="2020-04-08T13:17:38+08:00">2020-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/DFS-BFS/" itemprop="url" rel="index"><span itemprop="name">DFS/BFS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<p>示例 1：</p>
<p>输入：m = 2, n = 3, k = 1</p>
<p>输出：3</p>
<p>示例 2：</p>
<p>输入：m = 3, n = 1, k = 0</p>
<p>输出：1</p>
<p>提示：</p>
<p>1 &lt;= n,m &lt;= 100</p>
<p>0 &lt;= k &lt;= 20</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题目，我先想到的是，注意，比如坐标为（9，9)时，如果m=n=11,且 k = 8这种的话，那么(9,9),(9,10),(10,9)都不能访问，但是(10,10）是可以访问的，但是访问不到，被挡住了哦。初步看了第一感觉就是深度优先或者广度优先。这里就用python来写一次DFS或者BFS。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from typing import List</span><br><span class="line">def visit(x:int, y:int, k:int, jvzhen:List[List[int]], m:int, n:int) -&gt; int:</span><br><span class="line">	ans &#x3D; 0</span><br><span class="line">	step_dict &#x3D; &#123;0:[-1,0],1:[1,0],2:[0,-1],3:[0,1]&#125;  # 对应上下左右</span><br><span class="line">	for i in range(4):</span><br><span class="line">		loc_x &#x3D; x</span><br><span class="line">		loc_y &#x3D; y	</span><br><span class="line">		if (loc_x+step_dict[i][0])&gt;&#x3D;0 and (loc_x+step_dict[i][0])&lt;m and (loc_y+step_dict[i][1])&gt;&#x3D;0 and (loc_y+step_dict[i][1])&lt;n:			</span><br><span class="line">			num &#x3D; sum([int(a) for a in str(loc_x + step_dict[i][0])])+sum([int(b) for b in str(loc_y+step_dict[i][1])])</span><br><span class="line">			if num&lt;&#x3D;k and jvzhen[loc_x + step_dict[i][0]][loc_y+step_dict[i][1]] &#x3D;&#x3D; 0:</span><br><span class="line">				ans +&#x3D;1</span><br><span class="line">				loc_x &#x3D; loc_x + step_dict[i][0]</span><br><span class="line">				loc_y &#x3D; loc_y + step_dict[i][1]</span><br><span class="line">				jvzhen[loc_x][loc_y] &#x3D; 1</span><br><span class="line">				ans +&#x3D; visit(loc_x,loc_y,k,jvzhen,m,n)</span><br><span class="line">	return ans</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">	def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">		jvzhen &#x3D; np.zeros((m,n)).astype(int)</span><br><span class="line">		jvzhen[0][0] &#x3D; 1</span><br><span class="line">		ans &#x3D; visit(0,0,k,jvzhen,m,n)</span><br><span class="line">		return ans+1</span><br><span class="line">    	</span><br><span class="line">solu &#x3D; Solution()</span><br><span class="line">ans &#x3D; solu.movingCount(3,1,0)</span><br></pre></td></tr></table></figure>
<p>print(ans)</p>
<p>题目不难，但是由于自己的编程太垃圾，找bug找了半天，终于通过了。下面来看看官方给的题解分析</p>
<h2 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a>官方题解</h2><h3 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h3><p><strong>思路和算法</strong></p>
<p>我们将行坐标和列坐标数位之和大于 k 的格子看作障碍物，那么这道题就是一道很传统的搜索题目，我们可以使用广度优先搜索或者深度优先搜索来解决它，本文选择使用广度优先搜索的方法来讲解。</p>
<p>那么如何计算一个数的数位之和呢？我们只需要对数 x 每次对 10 取余，就能知道数 x 的个位数是多少，然后再将 x 除 10，这个操作等价于将 x 的十进制数向右移一位，删除个位数（类似于二进制中的 &gt;&gt; 右移运算符），不断重复直到 x 为 0 时结束。</p>
<p>同时这道题还有一个隐藏的优化：我们在搜索的过程中搜索方向可以缩减为向右和向下，而不必再向上和向左进行搜索。如下图，我们展示了 16 * 16 的地图随着限制条件 k 的放大，可行方格的变化趋势，每个格子里的值为行坐标和列坐标的数位之和，蓝色方格代表非障碍方格，即其值小于等于当前的限制条件 k。我们可以发现随着限制条件 k 的增大，(0, 0) 所在的蓝色方格区域内新加入的非障碍方格都可以由上方或左方的格子移动一步得到。而其他不连通的蓝色方格区域会随着 k 的增大而连通，且连通的时候也是由上方或左方的格子移动一步得到，因此我们可以将我们的搜索方向缩减为向右或向下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def digitsum(n):</span><br><span class="line">    ans &#x3D; 0</span><br><span class="line">    while n:</span><br><span class="line">        ans +&#x3D; n % 10</span><br><span class="line">        n &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">        from queue import Queue</span><br><span class="line">        q &#x3D; Queue()</span><br><span class="line">        q.put((0, 0))</span><br><span class="line">        s &#x3D; set()</span><br><span class="line">        while not q.empty():</span><br><span class="line">            x, y &#x3D; q.get()</span><br><span class="line">            if (x, y) not in s and 0 &lt;&#x3D; x &lt; m and 0 &lt;&#x3D; y &lt; n and digitsum(x) + digitsum(y) &lt;&#x3D; k:</span><br><span class="line">                s.add((x, y))</span><br><span class="line">                for nx, ny in [(x + 1, y), (x, y + 1)]:</span><br><span class="line">                    q.put((nx, ny))</span><br><span class="line">        return len(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;ji-qi-ren-de-yun-dong-fan-wei-lcof&#x2F;solution&#x2F;ji-qi-ren-de-yun-dong-fan-wei-by-leetcode-solution&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>时间复杂度：O(mn)O(mn)，其中 m 为方格的行数，n 为方格的列数。考虑所有格子都能进入，那么搜索的时候一个格子最多会被访问的次数为常数，所以时间复杂度为 O(2mn)=O(mn)O(2mn)=O(mn)。</p>
<p>空间复杂度：O(mn)O(mn)，其中 m 为方格的行数，n 为方格的列数。搜索的时候需要一个大小为 O(mn)O(mn) 的标记结构用来标记每个格子是否被走过。</p>
<h3 id="方法二：递推"><a href="#方法二：递推" class="headerlink" title="方法二：递推"></a>方法二：递推</h3><p><strong>思路</strong></p>
<p>考虑到方法一提到搜索的方向只需要朝下或朝右，我们可以得出一种递推的求解方法。</p>
<p><strong>算法</strong></p>
<p>定义 vis[i][j] 为 (i, j) 坐标是否可达，如果可达返回 1，否则返回 0。</p>
<p>首先 (i, j) 本身需要可以进入，因此需要先判断 i 和 j 的数位之和是否大于 k ，如果大于的话直接设置 vis[i][j] 为不可达即可。</p>
<p>否则，前面提到搜索方向只需朝下或朝右，因此 (i, j) 的格子只会从 (i - 1, j) 或者 (i, j - 1) 两个格子走过来（不考虑边界条件），那么 vis[i][j] 是否可达的状态则可由如下公式计算得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vis[i][j] &#x3D; vis[i-1][j] or vis[i][j-1]</span><br></pre></td></tr></table></figure>
<p>即只要有一个格子可达，那么 (i, j) 这个格子就是可达的，因此我们只要遍历所有格子，递推计算出它们是否可达然后用变量 ans 记录可达的格子数量即可。<br>初始条件 vis[i][j] = 1 ，递推计算的过程中注意边界的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def digitsum(n):</span><br><span class="line">    ans &#x3D; 0</span><br><span class="line">    while n:</span><br><span class="line">        ans +&#x3D; n % 10</span><br><span class="line">        n &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">    return ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">        vis &#x3D; set([(0, 0)])</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if ((i - 1, j) in vis or (i, j - 1) in vis) and digitsum(i) + digitsum(j) &lt;&#x3D; k:</span><br><span class="line">                    vis.add((i, j))</span><br><span class="line">        return len(vis)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong><br>时间复杂度：O(mn)O(mn)，其中 m 为方格的行数， n 为方格的列数。一共有 O(mn)O(mn) 个状态需要计算，每个状态递推计算的时间复杂度为 O(1)O(1)，所以总时间复杂度为 O(mn)O(mn)。</p>
<p>空间复杂度：O(mn)O(mn)，其中 m 为方格的行数，n 为方格的列数。我们需要 O(mn)O(mn) 大小的结构来记录每个位置是否可达。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了上面的题解，有几个收获。如题解中提到的，我们可以优化搜索方向，搜索方向其实只需要定义向下和向上就可以了。然后方法二的递推也是很好的想法</p>
<h2 id="优秀题解"><a href="#优秀题解" class="headerlink" title="优秀题解"></a>优秀题解</h2><h3 id="方法一：深度优先遍历-DFS"><a href="#方法一：深度优先遍历-DFS" class="headerlink" title="方法一：深度优先遍历 DFS"></a>方法一：深度优先遍历 DFS</h3><p><strong>深度优先搜索</strong>： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</p>
<p>剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p>
<p><strong>算法解析：</strong></p>
<p><strong>递归参数</strong>： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。</p>
<p>终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。</p>
<p><strong>递推工作：</strong></p>
<p><strong>标记当前单元格</strong> ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。</p>
<p>搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。</p>
<p>回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">        def dfs(i, j, si, sj):</span><br><span class="line">            if not 0 &lt;&#x3D; i &lt; m or not 0 &lt;&#x3D; j &lt; n or k &lt; si + sj or (i, j) in visited: return 0</span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            return 1 + dfs(i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj) + dfs(i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        visited &#x3D; set()</span><br><span class="line">        return dfs(0, 0, 0, 0)</span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;ji-qi-ren-de-yun-dong-fan-wei-lcof&#x2F;solution&#x2F;mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h3 id="方法二：广度优先遍历-BFS"><a href="#方法二：广度优先遍历-BFS" class="headerlink" title="方法二：广度优先遍历 BFS"></a>方法二：广度优先遍历 BFS</h3><p><strong>BFS/DFS </strong>： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。</p>
<p>BFS 实现： 通常利用队列实现广度优先遍历。</p>
<p><strong>算法解析</strong>：</p>
<p><strong>初始化</strong>： 将机器人初始点 (0, 0)(0,0) 加入队列 queue ；</p>
<p><strong>迭代终止条件</strong>： queue 为空。代表已遍历完所有可达解。</p>
<p><strong>迭代工作</strong>：</p>
<p><strong>单元格出队</strong>： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。</p>
<p><strong>判断是否跳过</strong>： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。</p>
<p><strong>标记当前单元格</strong> ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。</p>
<p><strong>单元格入队</strong>： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 。</p>
<p><strong>返回值</strong>： Set visited 的长度 len(visited) ，即可达解的数量。</p>
<p>Java 使用了辅助变量 res 统计可达解数量； Python 直接返回 Set 的元素数即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def movingCount(self, m: int, n: int, k: int) -&gt; int:</span><br><span class="line">        queue, visited,  &#x3D; [(0, 0, 0, 0)], set()</span><br><span class="line">        while queue:</span><br><span class="line">            i, j, si, sj &#x3D; queue.pop(0)</span><br><span class="line">            if not 0 &lt;&#x3D; i &lt; m or not 0 &lt;&#x3D; j &lt; n or k &lt; si + sj or (i, j) in visited: continue</span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            queue.append((i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj))</span><br><span class="line">            queue.append((i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8))</span><br><span class="line">        return len(visited)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;ji-qi-ren-de-yun-dong-fan-wei-lcof&#x2F;solution&#x2F;mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>此题解中的DFS比我写的看着舒服很多。可以向他学习一哈。然后BFS的队列实现也可以仔细看一下。多提高提高自己的编程能力</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/05/460%20LFU%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SAKURA">
      <meta itemprop="description" content="CS, AI, Daily Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SAKURA">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/05/460%20LFU%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">LeetCode problem460 LFU缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-05 11:41:34 / 修改时间：11:45:08" itemprop="dateCreated datePublished" datetime="2020-04-05T11:41:34+08:00">2020-04-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：get 和 put。</p>
<p>get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</p>
<p>put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，最近最少使用的键将被去除。</p>
<p>进阶：</p>
<p>你是否可以在 O(1) 时间复杂度内执行两项操作？</p>
<p>示例：</p>
<p>LFUCache cache = new LFUCache( 2 /<em> capacity (缓存容量) </em>/ );</p>
<p>cache.put(1, 1);</p>
<p>cache.put(2, 2);</p>
<p>cache.get(1);       // 返回 1</p>
<p>cache.put(3, 3);    // 去除 key 2</p>
<p>cache.get(2);       // 返回 -1 (未找到key 2)</p>
<p>cache.get(3);       // 返回 3</p>
<p>cache.put(4, 4);    // 去除 key 1</p>
<p>cache.get(1);       // 返回 -1 (未找到 key 1)</p>
<p>cache.get(3);       // 返回 3</p>
<p>cache.get(4);       // 返回 4</p>
<p>来源：力扣（LeetCode）</p>
<p>链接：<a href="https://leetcode-cn.com/problems/lfu-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>开始觉得可以加入一个有序字典，但是后来实现的时候还是不够用。</p>
<p>且看官方题解吧，自己的编程能力还是太水了：</p>
<p>方法二：双哈希表</p>
<p>思路和算法</p>
<p>我们定义两个哈希表，第一个 freq_table 以频率 freq 为索引，每个索引存放一个双向链表，这个链表里存放所有使用频率为 freq 的缓存，缓存里存放三个信息，分别为键 key，值 value，以及使用频率 freq。第二个 key_table 以键值 key 为索引，每个索引存放对应缓存在 freq_table 中链表里的内存地址，这样我们就能利用两个哈希表来使得两个操作的时间复杂度均为 O(1)O(1)。同时需要记录一个当前缓存最少使用的频率 minFreq，这是为了删除操作服务的。</p>
<p>对于 get(key) 操作，我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1，否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可。</p>
<p>但是我们注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。所以我们在当前链表中 O(1)O(1) 删除该缓存对应的节点，根据情况更新 minFreq 值，然后将其O(1)O(1) 插入到 freq + 1 索引下的链表头完成更新。这其中的操作复杂度均为 O(1)O(1)。你可能会疑惑更新的时候为什么是插入到链表头，这其实是为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。</p>
<p>对于 put(key, value) 操作，我们先通过索引 key在 key_table 中查看是否有对应的缓存，如果有的话，其实操作等价于 get(key) 操作，唯一的区别就是我们需要将当前的缓存里的值更新为 value。如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。</p>
<p>先考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 freq_table 中 1 索引下的列表头即可，同时更新 key_table[key] 的信息，以及更新 minFreq = 1。</p>
<p>那么剩下的就是删除操作了，由于我们实时维护了 minFreq，所以我们能够知道 freq_table 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的，所以 freq_table[minFreq] 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 minFreq ，整个时间复杂度均为 O(1)O(1)。</p>
<p>作者：LeetCode-Solution</p>
<p>链接：<a href="https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache/solution/lfuhuan-cun-by-leetcode-solution/</a></p>
<p>来源：力扣（LeetCode）</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, val, pre&#x3D;None, nex&#x3D;None, freq&#x3D;0):</span><br><span class="line">        self.pre &#x3D; pre</span><br><span class="line">        self.nex &#x3D; nex</span><br><span class="line">        self.freq &#x3D; freq</span><br><span class="line">        self.val &#x3D; val</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        </span><br><span class="line">    def insert(self, nex):  # 双向链表的插入节点操作</span><br><span class="line">        nex.pre &#x3D; self</span><br><span class="line">        nex.nex &#x3D; self.nex</span><br><span class="line">        self.nex.pre &#x3D; nex</span><br><span class="line">        self.nex &#x3D; nex</span><br><span class="line">    </span><br><span class="line">def create_linked_list():  # 空链表</span><br><span class="line">    head &#x3D; Node(0, 0)</span><br><span class="line">    tail &#x3D; Node(0, 0)</span><br><span class="line">    head.nex &#x3D; tail</span><br><span class="line">    tail.pre &#x3D; head</span><br><span class="line">    return (head, tail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class LFUCache:</span><br><span class="line">    def __init__(self, capacity: int):</span><br><span class="line">        self.capacity &#x3D; capacity</span><br><span class="line">        self.size &#x3D; 0</span><br><span class="line">        self.minFreq &#x3D; 0</span><br><span class="line">        self.freqMap &#x3D; collections.defaultdict(create_linked_list)</span><br><span class="line">        self.keyMap &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def delete(self, node):</span><br><span class="line">        if node.pre:</span><br><span class="line">            node.pre.nex &#x3D; node.nex</span><br><span class="line">            node.nex.pre &#x3D; node.pre</span><br><span class="line">            if node.pre is self.freqMap[node.freq][0] and node.nex is self.freqMap[node.freq][-1]:</span><br><span class="line">                self.freqMap.pop(node.freq)</span><br><span class="line">        return node.key</span><br><span class="line">        </span><br><span class="line">    def increase(self, node):</span><br><span class="line">        node.freq +&#x3D; 1</span><br><span class="line">        self.delete(node)</span><br><span class="line">        self.freqMap[node.freq][-1].pre.insert(node)</span><br><span class="line">        if node.freq &#x3D;&#x3D; 1:</span><br><span class="line">            self.minFreq &#x3D; 1</span><br><span class="line">        elif self.minFreq &#x3D;&#x3D; node.freq - 1:</span><br><span class="line"># 如果这个新调用的node freq值原来是最小freq值，那么就要看他原来所在的双链表中</span><br><span class="line">#除了head tail结点外是否还有节点，如果有就不动，如果没有，那么minfreq也要+1了</span><br><span class="line">            head, tail &#x3D; self.freqMap[node.freq - 1]</span><br><span class="line">            if head.nex is tail:</span><br><span class="line">                self.minFreq &#x3D; node.freq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get(self, key: int) -&gt; int:</span><br><span class="line">        if key in self.keyMap:</span><br><span class="line">            self.increase(self.keyMap[key])</span><br><span class="line">            return self.keyMap[key].val</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def put(self, key: int, value: int) -&gt; None:</span><br><span class="line">        if self.capacity !&#x3D; 0:</span><br><span class="line">            if key in self.keyMap:</span><br><span class="line">                node &#x3D; self.keyMap[key]</span><br><span class="line">                node.val &#x3D; value</span><br><span class="line">            else:</span><br><span class="line">                node &#x3D; Node(key, value)</span><br><span class="line">                self.keyMap[key] &#x3D; node</span><br><span class="line">                self.size +&#x3D; 1</span><br><span class="line">            if self.size &gt; self.capacity:</span><br><span class="line">                self.size -&#x3D; 1</span><br><span class="line">                deleted &#x3D; self.delete(self.freqMap[self.minFreq][0].nex)</span><br><span class="line">                self.keyMap.pop(deleted)</span><br><span class="line">            self.increase(node)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;lfu-cache&#x2F;solution&#x2F;lfuhuan-cun-by-leetcode-solution&#x2F;</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>这里面的思考过程对我来说还是比较复杂的，日后一定要来重写</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/google-colab%E8%B0%83%E8%AF%95faster%20rcnn%E8%AF%86%E8%99%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SAKURA">
      <meta itemprop="description" content="CS, AI, Daily Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SAKURA">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/30/google-colab%E8%B0%83%E8%AF%95faster%20rcnn%E8%AF%86%E8%99%AB/" class="post-title-link" itemprop="url">google_colab 调试faster rcnn识虫</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-30 20:07:38" itemprop="dateCreated datePublished" datetime="2020-03-30T20:07:38+08:00">2020-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-05 16:08:09" itemprop="dateModified" datetime="2020-04-05T16:08:09+08:00">2020-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/DL/" itemprop="url" rel="index"><span itemprop="name">DL</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/DL/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、本地数据集的制作"><a href="#一、本地数据集的制作" class="headerlink" title="一、本地数据集的制作"></a>一、本地数据集的制作</h1><p>首先从百度PandlePandle平台上获得了虫子的数据，原先已经在google colab上跑通了faster rcnn的源码，跑通的部分记录放在CSDN上面的。那部分的过程主要还是根据别人的教程一步一步来实现的，训练测试的数据是VOC2007</p>
<p>所以这里想自己将数据集格式改成VOC2007格式的，然后进行数据集的替换。然后训练测试来一发，看看自定义数据集的效果。</p>
<h2 id="数据集的更改："><a href="#数据集的更改：" class="headerlink" title="数据集的更改："></a>数据集的更改：</h2><ul>
<li>xml文件的修改<ul>
<li>xml文件中的几个标签内容要改</li>
</ul>
</li>
<li>虫子图片的格式为jpeg，后面替换数据集后发现程序报错，要把图片格式改成jpg格式的。这个比较简单，命令行界面下，到图片集的目录下， 然后  ren <em>.jpeg </em>.jpg</li>
<li>xml文件中标签内容批量修改时，用python批量修改后，这里想强调几点<ul>
<li>修改完成时，写入过程中保证编码方式还是原来的 UTF-8 编码</li>
<li>用记事本打开xml文件时会发现下方的信息   Unix(LF)  UTF-8。但是用python批量修改之后再打开，变成了windows(CR LF)。这里应该是换行的符号不同。还不知道对实验有没有影响。</li>
</ul>
</li>
<li>然后还想记下一些以后可能用得到的代码：<h2 id="批量修改文件夹下所有xml文件中的标签信息"><a href="#批量修改文件夹下所有xml文件中的标签信息" class="headerlink" title="批量修改文件夹下所有xml文件中的标签信息"></a>批量修改文件夹下所有xml文件中的标签信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xml.dom.minidom</span><br><span class="line"></span><br><span class="line">path = <span class="string">"C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/Annotations"</span></span><br><span class="line"></span><br><span class="line">files = os.listdir(path)  <span class="comment"># 得到文件夹下所有文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> xmlFile <span class="keyword">in</span> files:  <span class="comment"># 遍历文件夹</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(xmlFile):  <span class="comment"># 判断是否是文件夹,不是文件夹才打开</span></span><br><span class="line"></span><br><span class="line">        print(xmlFile)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将获取的xml文件名送入到dom解析</span></span><br><span class="line"></span><br><span class="line">        dom = xml.dom.minidom.parse(os.path.join(path, xmlFile))  <span class="comment"># 输入xml文件具体路径</span></span><br><span class="line"></span><br><span class="line">        root = dom.documentElement</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取标签&lt;name&gt;以及&lt;folder&gt;的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># name = root.getElementsByTagName('name')</span></span><br><span class="line"></span><br><span class="line">        folder = root.getElementsByTagName(<span class="string">'folder'</span>)</span><br><span class="line"></span><br><span class="line">        filename = root.getElementsByTagName(<span class="string">'filename'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个xml文件的多个同样的属性值进行修改。此处将每一个&lt;name&gt;属性修改为plane,每一个&lt;folder&gt;属性修改为VOC2007</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(len(name)):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     print(name[i].firstChild.data)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     name[i].firstChild.data = 'plane'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#     print(name[i].firstChild.data)</span></span><br><span class="line"></span><br><span class="line">        folder[<span class="number">0</span>].firstChild.data = <span class="string">"VOC2007"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(filename)):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(filename[i].firstChild.data)</span></span><br><span class="line"></span><br><span class="line">            lista = filename[i].firstChild.data.split(<span class="string">'.'</span>)</span><br><span class="line"></span><br><span class="line">            ans = lista[<span class="number">0</span>]+<span class="string">'.'</span>+<span class="string">"jpg"</span></span><br><span class="line"></span><br><span class="line">            filename[i].firstChild.data = ans</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(ans)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将属性存储至xml文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> open(os.path.join(path, xmlFile), <span class="string">'w'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> fh:   <span class="comment"># 门道相当多啊</span></span><br><span class="line"></span><br><span class="line">            dom.writexml(fh)</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'已写入'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="将文件夹下所有图片名读取出来，写入txt文件中"><a href="#将文件夹下所有图片名读取出来，写入txt文件中" class="headerlink" title="将文件夹下所有图片名读取出来，写入txt文件中"></a>将文件夹下所有图片名读取出来，写入txt文件中</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line">results = set()</span><br><span class="line"></span><br><span class="line">path = <span class="string">"C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/JPEGImages/test"</span></span><br><span class="line"></span><br><span class="line">files = os.listdir(path)  <span class="comment"># 得到文件夹下所有文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filenames <span class="keyword">in</span> files:</span><br><span class="line"></span><br><span class="line">    filename = filenames.split(sep=<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    results.add(filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(len(results))</span><br><span class="line"></span><br><span class="line">txt_path = <span class="string">"C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/test.txt"</span></span><br><span class="line"></span><br><span class="line">new_file = open(txt_path,<span class="string">'w+'</span>,encoding=<span class="string">'UTF-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> str <span class="keyword">in</span> results:</span><br><span class="line"></span><br><span class="line">    new_file.write(str+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">new_file.close()</span><br></pre></td></tr></table></figure>
<h2 id="数据集的训练、验证、测试数据集的分割"><a href="#数据集的训练、验证、测试数据集的分割" class="headerlink" title="数据集的训练、验证、测试数据集的分割"></a>数据集的训练、验证、测试数据集的分割</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*<span class="string">"""*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*将数据集进行比例分割，分割成train,val,test,*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*生成  train.txt, val.txt,  test.txt,  trainval.txt*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*"""</span>*</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">trainval_percent = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">train_percent = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">xmlfilepath = <span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/Annotations'</span></span><br><span class="line"></span><br><span class="line">txtsavepath = <span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/Main'</span></span><br><span class="line"></span><br><span class="line">total_xml = os.listdir(xmlfilepath)</span><br><span class="line"></span><br><span class="line">num = len(total_xml)</span><br><span class="line"></span><br><span class="line">list = range(num)</span><br><span class="line"></span><br><span class="line">tv = int(num * trainval_percent)</span><br><span class="line"></span><br><span class="line">tr = int(tv * train_percent)</span><br><span class="line"></span><br><span class="line">trainval = random.sample(list, tv)</span><br><span class="line"></span><br><span class="line">train = random.sample(trainval, tr)</span><br><span class="line"></span><br><span class="line">ftrainval = open(<span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/Main/trainval.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">ftest = open(<span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/Main/test.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">ftrain = open(<span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/Main/train.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">fval = open(<span class="string">'C:/Users/Administrator/Desktop/AI_studio/PaddleDetection/dataset/insect/ImageSets/Main/val.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list:</span><br><span class="line"></span><br><span class="line">    name = total_xml[i][:<span class="number">-4</span>] + <span class="string">'\n'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> trainval:</span><br><span class="line"></span><br><span class="line">        ftrainval.write(name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> train:</span><br><span class="line"></span><br><span class="line">            ftrain.write(name)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            fval.write(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        ftest.write(name)</span><br><span class="line"></span><br><span class="line">ftrainval.close()</span><br><span class="line"></span><br><span class="line">ftrain.close()</span><br><span class="line"></span><br><span class="line">fval.close()</span><br><span class="line"></span><br><span class="line">ftest.close()</span><br></pre></td></tr></table></figure>
<h2 id="文件格式转换-window-转换为unix"><a href="#文件格式转换-window-转换为unix" class="headerlink" title="文件格式转换 window 转换为unix"></a>文件格式转换 window 转换为unix</h2><p><a href="https://www.cnblogs.com/TurboWay/p/9687576.html" target="_blank" rel="noopener">https://www.cnblogs.com/TurboWay/p/9687576.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line">import chardet</span><br><span class="line"></span><br><span class="line">def turn(file):</span><br><span class="line">    with open(file, &#39;rb&#39;) as f:</span><br><span class="line">        data &#x3D; f.read()</span><br><span class="line">        encoding &#x3D; chardet.detect(data)[&#39;encoding&#39;]</span><br><span class="line">        data_str &#x3D; data.decode(encoding)</span><br><span class="line">        tp &#x3D; &#39;LF&#39;</span><br><span class="line">        if &#39;\r\n&#39; in data_str:</span><br><span class="line">            tp &#x3D; &#39;CRLF&#39;</span><br><span class="line">            data_str &#x3D; data_str.replace(&#39;\r\n&#39;, &#39;\n&#39;)</span><br><span class="line">        if encoding not in [&#39;utf-8&#39;, &#39;ascii&#39;] or tp &#x3D;&#x3D; &#39;CRLF&#39;:</span><br><span class="line">            with open(file, &#39;w&#39;, newline&#x3D;&#39;\n&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">                f.write(data_str)</span><br><span class="line">            print(f&quot;&#123;file&#125;: (&#123;tp&#125;,&#123;encoding&#125;) trun to (LF,utf-8) success!&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    if sys.argv.__len__() !&#x3D; 2:</span><br><span class="line">        print(f&quot;param: python3 etl_file_check.py &#x2F;home&#x2F;getway&#x2F;script&#x2F;hql&quot;)</span><br><span class="line">    else:</span><br><span class="line">        dr &#x3D; sys.argv[1]</span><br><span class="line">        for path in os.listdir(dr):</span><br><span class="line">            file &#x3D; os.path.join(dr, path)</span><br><span class="line">            if os.path.isfile(file):</span><br></pre></td></tr></table></figure>
<pre><code>            turn(file)
</code></pre><h2 id="2-21日又开始调试了"><a href="#2-21日又开始调试了" class="headerlink" title="2.21日又开始调试了"></a>2.21日又开始调试了</h2><p>今天将数据集搞好后，开始调试训练代码报的错误。还好有大佬们的博客博客帮忙</p>
<p><a href="https://www.cnblogs.com/wind-chaser/p/11359521.html" target="_blank" rel="noopener">https://www.cnblogs.com/wind-chaser/p/11359521.html</a></p>
<p>博客上面一样的问题我就不记录了，下面是自己遇到的问题</p>
<ul>
<li>训练时报错内容是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls &#x3D; self._class_to_ind[obj.find(&#39;name&#39;).text.lower().strip()]</span><br></pre></td></tr></table></figure>
网上的说法不尽相同，尝试了几次都没有搞对，后面自己去看了下源代码。简单介绍下<br>源文件的处理过程是先从trainval.txt 中读取出要训练验证的数据是哪些图片和xml，然后程序从对应的xml文件中读取出object标签下的信息，也就是一张图中所有的目标信息，这些目标信息再以程序自己的格式存储下来（也就是定义多个列表，比如位置信息），最后还要存储目标的类别信息，问题就出在这，程序会把读到的类别信息转成小写，然后再去字典（这个字典是几个类别分别对应的索引）查找该类索引，最后记录类别信息也就是记录字典的索引。因为字典中的类别key值有几个是大写，所以没有匹配上就一直报错啦。OK</li>
</ul>
<p>处理完这个错误之后继续训练，报错如下：</p>
<p><img src="/images/google_colab_faster_rcnn/1.png" alt="图片"></p>
<p>也不知道调试了多久，主要网上没找到相似的情况，所以把我都搞醉了，大概是去原作者的github中的说明中去找步骤，发现以前版本的代码有一个脚本文件，而新版本代码中倒是没有，上面报错的情况大概是配置的问题，有关GPU问题的，而且还是ROIAlign部分出的问题，本来这是Mask RCNN中才有的模块，原作者也说了他们提供了几种pooling技术而且都实现了，所以代码应该是默认用了Mask RCNN中更好的模块替代了 ROI Pooling吧。好了，说这么多其实对于后面解决该问题也没什么逻辑可言。</p>
<p>我直觉觉得可能是模块编译出了问题，所以我就又编译了一下，还是不对。</p>
<p>继续研究目录结构，在将作者的代码clone下来时，lib文件夹下并没有build文件夹，那就很好理解，肯定是编译的时候产生的啦，之前重新编译不行，那就大概率是因为编译文件已经产生了，就没有重新来一遍。我就果断的删除了build文件，重新编译，再次运行训练命令，果真开始训练了。那感觉，确实不错！</p>
<p>后续train_net、 test_net、 demo都试了一下，不知道demo放入的数据是已经训练的数据还是啥原因，看起来也太准了吧。后面再仔细分类一下 百度的AI试虫数据集，把未训练的数据集放入项目中demo一下，看看准确率如何</p>
<p>情况如下：</p>
<p><img src="/images/google_colab_faster_rcnn/2.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/3.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/4.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/5.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/6.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/7.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/8.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/9.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/10.png" alt="图片"><br><img src="/images/google_colab_faster_rcnn/11.png" alt="图片"></p>
<p>第二张和第六张中各有一个小目标都有重复框，第八张的预测不是很理想。后续就要改进这些不足了。还有的是，随机看了一张图 2571.jpg 也就是上面的第三张图  2571.xml中竟然给了七个框，我人都晕了。这是什么情况啊。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/30/google_colab_yolov3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="SAKURA">
      <meta itemprop="description" content="CS, AI, Daily Life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SAKURA">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/30/google_colab_yolov3/" class="post-title-link" itemprop="url">google_colab 实验yolov3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-30 20:07:38" itemprop="dateCreated datePublished" datetime="2020-03-30T20:07:38+08:00">2020-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-05 15:56:56" itemprop="dateModified" datetime="2020-04-05T15:56:56+08:00">2020-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/AI/DL/" itemprop="url" rel="index"><span itemprop="name">DL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Github代码地址：<a href="https://github.com/sakurasakura1996/PyTorch-YOLOv3" target="_blank" rel="noopener">https://github.com/sakurasakura1996/PyTorch-YOLOv3</a></p>
<p>配套的教程还是比较详细的，就是教程是根据coco数据集来训练的，我们要先下载coco数据集，train加val的都特么快20G了，我不能保存在goole drive里面，所以下载下来一旦掉线就木了，难受啊，这里记录的时候还没有下好数据集，这里主要是记录后面训练自己的自定义的数据集，他这个数据集的布局好像不太常见，所以要把虫的数据集改为适用的数据集还是比较麻烦的。</p>
<h1 id="自定义数据制作"><a href="#自定义数据制作" class="headerlink" title="自定义数据制作"></a>自定义数据制作</h1><p>需要的改动是：</p>
<ul>
<li>所有的数据集放在data/custom文件夹下</li>
<li>custom文件夹下有images文件夹，labels文件夹，classes.names文件，train.txt,valid.txt</li>
<li>images文件夹下就直接放所有的图片</li>
<li>labels文件夹下放的是txt文件，目前还不知道应该以什么样的方式来存储，<ul>
<li>有可能是images文件夹下的每张图片都对应一个同名的txt文件在labels文件夹下，标注的是该图片中的目标区域信息 格式为  类别索引（从0开始），中心点横坐标，中心点纵坐标，宽，高   五个数据，这张图片中有几个框，就有几行这样的数据</li>
<li>想了下，应该没有其他情况了，就是这样做的，所以要改动的话就是遍历原来数据集中的xml文件，找出目标框，然后把xmin，ymin，xmax，ymax这样的值转换为中心点坐标值和宽高的格式，而且把这些值都转换为0-1的格式i，也就是坐标的比例。</li>
</ul>
</li>
<li>classes.names文件内容比较简单，就是存放的几种数据集的类别</li>
<li>train.txt   存放训练图片的路径，每张图片的路径都是一行</li>
<li>valid.txt  存放验证图片的路径，每张图片的路径都是一行</li>
</ul>
<p>今晚看来这个数据集是下载不动了。没实体电脑难受啊。</p>
<p>OK，2020.3.15开始制作数据集啦</p>
<p>下面代码是把所有的xml文件读入，然后进行数据转换，生成对应xml同名的txt文件。并把要求的数据进行计算生成写入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">现在想用google colab来实验YOLOv3，但是看github这个作者的代码要求的自定义数据格式还是和原来训练的faster rcnn制作的数据集</span><br><span class="line">很不一样，所以就开始制作数据集了</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line">import xml.dom.minidom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;AI_studio&#x2F;PaddleDetection&#x2F;dataset&#x2F;insect&#x2F;Annotations&quot;</span><br><span class="line">write_path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;pytorch-yolov3&#x2F;custom&#x2F;labels&quot;</span><br><span class="line">files &#x3D; os.listdir(path)  # 得到文件夹下所有文件名称</span><br><span class="line"></span><br><span class="line">label_dict &#x3D; &#123;</span><br><span class="line">    &#39;Boerner&#39;:0,</span><br><span class="line">    &#39;linnaeus&#39;:1,</span><br><span class="line">    &#39;armandi&#39;:2,</span><br><span class="line">    &#39;coleoptera&#39;:3,</span><br><span class="line">    &#39;Linnaeus&#39;:4,</span><br><span class="line">    &#39;Leconte&#39;:5,</span><br><span class="line">    &#39;acuminatus&#39;:6</span><br><span class="line">&#125;</span><br><span class="line">for filename in files:</span><br><span class="line">    dom &#x3D; xml.dom.minidom.parse(os.path.join(path,&#39;1.xml&#39;))</span><br><span class="line">    root &#x3D; dom.documentElement</span><br><span class="line">    width &#x3D; int(root.getElementsByTagName(&#39;width&#39;)[0].firstChild.data)</span><br><span class="line">    height &#x3D; int(root.getElementsByTagName(&#39;height&#39;)[0].firstChild.data)</span><br><span class="line">    name &#x3D; root.getElementsByTagName(&#39;name&#39;)</span><br><span class="line">    xmin &#x3D; root.getElementsByTagName(&#39;xmin&#39;)</span><br><span class="line">    ymin &#x3D; root.getElementsByTagName(&#39;ymin&#39;)</span><br><span class="line">    xmax &#x3D; root.getElementsByTagName(&#39;xmax&#39;)</span><br><span class="line">    ymax &#x3D; root.getElementsByTagName(&#39;ymax&#39;)</span><br><span class="line">    # for i in range(len(xmin)):</span><br><span class="line">    #     print(xmin[i].firstChild.data)</span><br><span class="line">    #     print(ymin[i].firstChild.data)</span><br><span class="line">    #     print(xmax[i].firstChild.data)</span><br><span class="line">    #     print(ymax[i].firstChild.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    with open(os.path.join(write_path,filename.split(&#39;.&#39;)[0]+&#39;.&#39;+&#39;txt&#39;),&#39;w&#39;,encoding&#x3D;&#39;UTF-8&#39;) as fh:</span><br><span class="line">    # 然后根据每一个框的上面五个信息，计算出格式为  index(目标框所属分类的索引）,中心点横坐标，中心点纵坐标，宽，高</span><br><span class="line">        for i in range(len(name)):</span><br><span class="line">            idx &#x3D; label_dict[name[i].firstChild.data]</span><br><span class="line">            center_x &#x3D; round((int(xmin[i].firstChild.data) + (int(xmax[i].firstChild.data)-int(xmin[i].firstChild.data))&#x2F;2)&#x2F;width,3)</span><br><span class="line">            center_y &#x3D; round((int(ymin[i].firstChild.data) + (int(ymax[i].firstChild.data)-int(ymin[i].firstChild.data))&#x2F;2)&#x2F;height,3)</span><br><span class="line">            width_gt &#x3D; round((int(xmax[i].firstChild.data)-int(xmin[i].firstChild.data))&#x2F;width,8)</span><br><span class="line">            height_gt &#x3D; round((int(ymax[i].firstChild.data)-int(ymin[i].firstChild.data))&#x2F;height, 8)</span><br><span class="line">            print(idx,center_x,center_y,width_gt,height_gt)</span><br><span class="line">            str_temp &#x3D; str(idx) +&#39; &#39; + str(center_x) +&#39; &#39; + str(center_y) +&#39; &#39; + str(width_gt) +&#39; &#39; + str(height_gt)+ &#39;\n&#39;</span><br><span class="line">            fh.write(str_temp,)</span><br><span class="line">    fh.close()</span><br></pre></td></tr></table></figure>
<p>这样就搞定啦</p>
<p>下面是写入train.txt 和 valid.txt，还是遇到了一些小问题的，在代码注释中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">这里的代码是制作yolo适用的数据集时，制作的train.txt 和 valid.txt</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line">train_path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;AI_studio&#x2F;PaddleDetection&#x2F;dataset&#x2F;insect&#x2F;ImageSets&#x2F;Main&#x2F;train.txt&quot;</span><br><span class="line">valid_path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;AI_studio&#x2F;PaddleDetection&#x2F;dataset&#x2F;insect&#x2F;ImageSets&#x2F;Main&#x2F;val.txt&quot;</span><br><span class="line"></span><br><span class="line">write_train_path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;pytorch-yolov3&#x2F;custom&#x2F;train.txt&quot;</span><br><span class="line">write_valid_path &#x3D; &quot;C:&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;pytorch-yolov3&#x2F;custom&#x2F;valid.txt&quot;</span><br><span class="line">write_train_list &#x3D;[]</span><br><span class="line">write_valid_list &#x3D; []</span><br><span class="line">with open(train_path,mode&#x3D;&#39;r&#39;) as f:</span><br><span class="line">    flist &#x3D; f.readlines()</span><br><span class="line">    for line in flist:</span><br><span class="line">        # 终于知道为什么下面自动换行了，这里输入print(line)就知道了，这里的line自带了换行符，所以 .jpg就只能</span><br><span class="line">        # 换行显示，可以先转换成int，再转换成str就可以了，OK</span><br><span class="line">        line &#x3D; &#39;data&#x2F;custom&#x2F;images&#x2F;&#39;+str(int(line))+&#39;.jpg\n&#39; # 不知道为什么这里写入的时候会把  .jpg换行写入，蒙蔽了</span><br><span class="line">        write_train_list.append(line)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">with open(write_train_path,mode&#x3D;&#39;w&#39;,encoding&#x3D;&#39;UTF-8&#39;) as f:</span><br><span class="line">    for line in write_train_list:</span><br><span class="line">        f.write(line)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">with open(valid_path,mode&#x3D;&#39;r&#39;) as f:</span><br><span class="line">    flist &#x3D; f.readlines()</span><br><span class="line">    for line in flist:</span><br><span class="line">        line &#x3D; str(&#39;data&#x2F;custom&#x2F;images&#x2F;&#39;+str(int(line))+&#39;.jpg\n&#39;)</span><br><span class="line">        write_valid_list.append(line)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">with open(write_valid_path,mode&#x3D;&#39;w&#39;,encoding&#x3D;&#39;UTF-8&#39;) as f:</span><br><span class="line">    for line in write_valid_list:</span><br><span class="line">        f.write(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<h1 id="2020-4-1日训练调试"><a href="#2020-4-1日训练调试" class="headerlink" title="2020.4.1日训练调试"></a>2020.4.1日训练调试</h1><p>好久没做，今天再调试一下。因为上次调试的结果出错了，所以就没搞了。</p>
<p>结果这次跑是跑通了但是 检测结果 太垃圾了，完全不对啊，上次faster rcnn的结果其实还可以。所以我怀疑上面的自定义数据集的目标框的坐标是不是没有搞对。后期再检查一下。今天先记录一下。</p>
<p>调试过程中遇到了几个问题，在github上面的issue中都可以找到问题所在，这里就不记录了。</p>
<p>github的交流区还是很好的。</p>
<p>再记录下检测数据不准确的可能原因。我感觉可能是我标注数据的问题，因为原来AI_Studio的数据集中目标框的信息是左上角和右小角的x，y坐标。而yolov3需要的目标框的信息是中心点坐标和宽度高度，且四个数据都是经过标准化之后的显示，这里涉及到一个坐标系的问题，一张图片的哪个地方才是（0,0）点，我可能和该程序了解的不一样，所以后续还要确认一下是不是该问题，因为预测样本结果完全不正确啊。同时对比了一下该程序和之前实验的faster rcnn结果，yolov3将原图像进行了resize，分辨率变低了，faster rcnn分辨率要高一些。加油调试一下这次</p>
<p>遇到的问题！</p>
<p>现在的情况如下：后续结果好了，再来记录。</p>
<p><img src="/images/google_colab_yolov3/1.png" alt="图片"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SAKURA"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">SAKURA</p>
  <div class="site-description" itemprop="description">CS, AI, Daily Life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SAKURA</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
